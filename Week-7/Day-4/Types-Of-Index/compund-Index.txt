2. Compound Index:

- A compound index is an index created on multiple fields of a document, and the order of fields matters. 
MongoDB follows the left-prefix rule, which means the query must start with the first indexed field to use the index.
For example, if we create an index on city and age, MongoDB first sorts by city and then by age inside each city.

- If any field in a compound index is an array, MongoDB automatically converts it into a multikey index. 
but MongoDB doesn’t allow more than one array fields, because it would create too many index combinations and can use more storage.

- Also, if all queried fields are present in the index, MongoDB can return results directly from the index without touching the actual documents. 
This is called a covering index.


Example:
db.users.createIndex({ city: 1, age: -1 })
First sorted by city (ASC)
Then inside each city, sorted by age (DESC)

> Why order matters? bcz The order of fields changes how MongoDB uses the index.

> If any field used in the index is an array, the whole index becomes a multikey index.
ex: { tags: ["mern", "node"], city: "Kochi" }
index: createIndex({ tags: 1, city: 1 })

Each element of the array creates a separate index key like => (node, Kochi), (mern, Kochi)
MongoDB automatically creates a multikey compound index.

> queries can use this multikey compound index as -
find({ tags: "node", city: "Kochi" })
Also, find({ tags: "node" })
> But does NOT work well when both fields are arrays

ex: tags: ["node", "mern"]
    skills: ["frontend", "backend"]
Index: createIndex({ tags: 1, skills: 1 })

MongoDB does NOT allow two array fields in the same compound index
This is to avoid explosions like:
node + frontend
node + backend
mern + frontend
mern + backend
Too many combinations → index becomes huge → forbidden.

> If the query needs ONLY fields inside the index, MongoDB doesn't touch the actual document.
ex: { city: 1, age: 1 }
query: find({ city: "Kochi" }, { city: 1, age: 1, _id: 0 })
MongoDB fetches the result directly from the Index


> Left Prefix Rule:
> MongoDB can use a compound index only if the query starts from the first field(s) of the index.
> > Supported Patterns: Equality -> Sort -> Range
{ city: 1, age: 1, score: 1 }

| Query                                   | Can Use Index?                       |
| --------------------------------------- | ------------------------------------ |
| `{ city: "Kochi" }`                     |     Yes                              |
| `{ city: "Kochi", age: 22 }`            |     Yes                              |
| `{ city: "Kochi", age: 22, score: 89 }` |     Yes                              |
| `{ age: 22 }`                           |     No (city missing!)               |
| `{ score: 89 }`                         |     No                               |
| `{ age: 22, score: 89 }`                |     No                               |
| `({ city: "Kochi"}).sort(score:1)       |     No (age missed)                  |
| `( city:Kochi,age:$gt:20).sort(score:1)`|   No (after range, the next breaks)  |
| `( city:Kochi,score:$gt:20).sort(age:1)`|   Yes (age is sort, score is range)  |
| `{ age: 22, score: 89 }`                |     No                               |


> Compound Index helps with both filter + sort
Ex: db.users.createIndex({ city: 1, age: 1 })
query: db.users.find({ city: "Kochi" }).sort({ age: 1 })