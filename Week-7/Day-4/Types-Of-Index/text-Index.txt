4. Text Index:

- Text index is used for searching words inside string fields.
- Normal indexes only matches full strings, but text index can search individual words like 'developer' even if the full value is 'Full Stack Developer'.

- Internally how it works is, first everything is converted to lowercase called normalization then 
  It breaks the text into individual words which is called tokenization. 
  Then, stop words are removed, and stemming reduces the words into their root form.
  After that, an inverted index is created where each word points to the documents that containing it.

- Only one text index is allowed per collection, and it's not for sorting or range queries, mainly for text searching.


It enables features like:
Word-based search
Phrase search
Language-based stemming


> Why do we need a Text Index?
Normal indexes: Work well for exact matches (=, <, >)

> Example:
{ title: "Full Stack Developer" }
{ title: "Backend Developer" }

normal index: db.jobs.createIndex({ title: 1 }) -> This index works like a dictionary
we have to find like this : find({ title: "Backend Developer" })

suppose we search "developer" But stored value is : "Full Stack Developer"
Normal index fails because It tries to match the whole string, it does NOT understand words inside the string

so, Text search needs:
   Searching words, not exact strings
   Ignoring case by default
   Handling language rules (run, running → run)

Creating a Text Index:

1. Single field text index:
db.jobs.createIndex({ title: "text" })

2. Multiple fields text index:
db.jobs.createIndex({
  title: "text",
  description: "text",
  skills: "text"
})                        //this is allowed

Note: Only ONE text index is allowed per collection.
db.products.createIndex({ title: "text" })
db.products.createIndex({ description: "text" })       //not allowed


> Default Language in Text Index is english
db.jobs.createIndex(
  { description: "text" },
  { default_language: "english" }
)

> Supports multiple fields:

if our document is
{
  title: "Backend Developer",
  description: "Node.js and MongoDB experience",
  skills: "JavaScript MongoDB Express"
}

we create ONE text index in one collection like this:
db.jobs.createIndex({
  title: "text",
  description: "text",
  skills: "text"
})
Now MongoDB treats all these fields as one search space.

When user searches : $search: "MongoDB"
MongoDB will check: description and skills
Even though the word is not in title, the document is returned.

Without this text index:
find({
  $or: [
    { title: /MongoDB/i },
    { description: /MongoDB/i },
    { skills: /MongoDB/i }
  ]
})
Slow, messy, bad for large data.


HOW MONGODB TEXT SEARCH WORKS INTERNALLY:

Phase 1: Index Creation Time (One-time process)

1. Read indexed fields:

MongoDB reads only the fields included in the text index
example FIELDS: title, description, skills 

2. Normalization:

MongoDB converts words to a standard form.
MongoDB → mongodb
Developer → developer
So searches become case-insensitive.

3. Tokenization:

MongoDB breaks the text into individual words (tokens)
Example text
"Looking for a backend developer with MongoDB experience"
After tokenization => looking, for, a, backend, developer, with, mongodb, experience

4. Remove stop words:

MongoDB removes common words that don’t add meaning.
Removed words => for, a, with
Remaining words => looking, backend, developer, mongodb, experience
Bcz these words appear everywhere, Indexing them wastes space and time

5. Stemming:

MongoDB reduces words to their root form.
Examples
developing → develop
developer → develop
developed → develop
This helps MongoDB understand word variations.

6. Build Inverted Index:

stemmed words are stored in separate text index, not inside document
MongoDB builds an inverted index that maps words to document IDs.
Example inverted index
backend   → doc1
developer → doc1, doc2
mongodb   → doc1, doc2, doc3
react     → doc2
This allows MongoDB to:
> Find documents by words quickly


Phase 2: Search Time (Every query)

> What happens on search:
Step 1: User enters search text  ->  "Backend Developer"
Step 2: Applies the same steps used during indexing:
Step 3: MongoDB looks up words in the inverted index
Step 4: MongoDB finds matching document IDs
Step 5: Matching documents are returned


> When words are long, Index size increases, Not the document size
but it does NOT become a big problem bcz-
Reason 1: Inverted index is compact.  word → [DocIDs]
If "mongodb" appears 100 times, stored once. So repetition does not explode memory.
Reason 2: Index is optimized & compressed
